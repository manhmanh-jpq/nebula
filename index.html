<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Xmas Perfected - Nitro Lite 16</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; }
        #canvas-container { position: absolute; width: 100%; height: 100%; z-index: 1; }
        
        /* M√†n h√¨nh nh·ªè g√≥c ph·∫£i - B·∫ÆT BU·ªòC HI·ªÜN */
        #pip-container { 
            position: absolute; bottom: 20px; right: 20px; width: 200px; height: 150px; 
            border: 3px solid #ff0000; border-radius: 15px; overflow: hidden; z-index: 1000;
            background: #222; box-shadow: 0 0 20px rgba(255,0,0,0.5);
        }
        #pip-video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

        /* Ch√∫ th√≠ch ƒë√∫ng 2 c√°i b·∫°n y√™u c·∫ßu */
        #guide { 
            position: absolute; top: 20px; left: 20px; z-index: 100; 
            background: rgba(0,0,0,0.8); color: white; padding: 15px; border-radius: 10px;
            border-left: 5px solid gold; pointer-events: none;
        }
        .line { margin: 5px 0; font-size: 14px; font-weight: bold; }

        /* Giao di·ªán n√∫t b·∫•m d∆∞·ªõi c√πng */
        #controls { 
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); 
            z-index: 100; display: flex; gap: 20px; 
        }
        .btn { 
            padding: 15px 25px; border-radius: 50px; border: none; cursor: pointer;
            font-weight: 900; background: white; transition: 0.3s;
        }

        /* B·ªô ch·ªçn m√†u */
        #colors { 
            position: absolute; top: 20px; right: 20px; z-index: 100; 
            background: rgba(0,0,0,0.8); padding: 10px; border-radius: 10px; color: white;
        }
        .c-item { display: flex; justify-content: space-between; gap: 10px; margin: 4px 0; font-size: 12px; }
    </style>
</head>
<body>

    <div id="guide">
        <div class="line">üñêÔ∏è 1 Tay: Xoay 360 ƒë·ªô</div>
        <div class="line">üôå 2 Tay: Ph√≥ng to m·ªü r·ªông</div>
        <div class="line">üé® M√†u: Ng√¥i sao, 5 t·∫ßng l√°, G·ªëc</div>
    </div>

    <div id="pip-container"><video id="pip-video" autoplay playsinline></video></div>
    <div id="canvas-container"></div>

    <div id="controls">
        <button class="btn" onclick="capture()">üì∑ ·∫§N V√ÄO ƒê√ÇY ƒê·ªÇ SELFI NH√ì BABE</button>
        <button class="btn" onclick="startRecord()">üéôÔ∏è ·ªû ƒê√ÇY L√Ä QUAY K√àM MIC LU√îN ƒê√ì</button>
    </div>

    <div id="colors">
        <div class="c-item">Sao <input type="color" id="c0" value="#ffff00"></div>
        <div class="c-item">L√° 1 <input type="color" id="c1" value="#003300"></div>
        <div class="c-item">L√° 2 <input type="color" id="c2" value="#004d00"></div>
        <div class="c-item">L√° 3 <input type="color" id="c3" value="#006600"></div>
        <div class="c-item">L√° 4 <input type="color" id="c4" value="#008000"></div>
        <div class="c-item">L√° 5 <input type="color" id="c5" value="#228b22"></div>
        <div class="c-item">G·ªëc <input type="color" id="c6" value="#4b240a"></div>
    </div>

    <script>
        let scene, camera, renderer, pts, geo, textSprite;
        let zoom = 1, rotY = 0, state = "TREE"; 
        let sZoom = 1, sRot = 0;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 3000);
            camera.position.z = 800;
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            geo = new THREE.BufferGeometry();
            const positions = new Float32Array(20000 * 3);
            const colors = new Float32Array(20000 * 3);
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // T·∫°o h·∫°t tr√≤n x·ªãn b·∫±ng Shader
            const mat = new THREE.PointsMaterial({
                size: 6, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending,
                map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/circle.png')
            });

            pts = new THREE.Points(geo, mat);
            scene.add(pts);

            // Ch·ªØ n·∫±m trong l√µi
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = "bold 40px Arial"; ctx.fillStyle = "white"; ctx.textAlign = "center";
            const tex = new THREE.CanvasTexture(canvas);
            textSprite = new THREE.Sprite(new THREE.SpriteMaterial({map: tex, transparent: true}));
            textSprite.scale.set(400, 100, 1);
            scene.add(textSprite);

            drawTree();
            animate();
            startCamera();
        }

        function drawTree() {
            const pos = geo.attributes.position.array;
            const col = geo.attributes.color.array;
            const c = [0,1,2,3,4,5,6].map(i => new THREE.Color(document.getElementById('c'+i).value));

            for(let i=0; i<20000; i++) {
                let x,y,z, clr;
                const r = Math.random();
                if(r > 0.15) { // T·∫ßng l√°
                    const t = Math.floor(Math.random()*5);
                    const h = -200 + t*80 + Math.random()*80;
                    const rad = (400 - (h+200)) * 0.4 * Math.random();
                    const a = Math.random() * Math.PI * 2;
                    x = Math.cos(a)*rad; y = h; z = Math.sin(a)*rad;
                    clr = c[t+1];
                } else if(r > 0.05) { // G·ªëc
                    x = (Math.random()-0.5)*50; y = -250-Math.random()*50; z = (Math.random()-0.5)*50;
                    clr = c[6];
                } else { // Sao
                    x = (Math.random()-0.5)*40; y = 220+Math.random()*40; z = (Math.random()-0.5)*40;
                    clr = c[0];
                }
                pos[i*3]=x; pos[i*3+1]=y; pos[i*3+2]=z;
                col[i*3]=clr.r; col[i*3+1]=clr.g; col[i*3+2]=clr.b;
            }
            geo.attributes.position.needsUpdate = true;
            geo.attributes.color.needsUpdate = true;
        }

        function drawHeart() {
            const pos = geo.attributes.position.array;
            for(let i=0; i<20000; i++) {
                const t = Math.random()*Math.PI*2;
                const p = Math.random()*Math.PI;
                const r = 18 + Math.random()*2; // T·∫°o ƒë·ªô d√†y kh·ªëi 3D
                pos[i*3] = r * 16 * Math.pow(Math.sin(t), 3) * Math.sin(p);
                pos[i*3+1] = r * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * Math.sin(p);
                pos[i*3+2] = r * 10 * Math.cos(p);
            }
            geo.attributes.position.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            sRot += (rotY - sRot) * 0.05;
            sZoom += (zoom - sZoom) * 0.05;
            pts.rotation.y = sRot;
            camera.position.z = 800 - (sZoom - 1) * 1500;

            const ctx = textSprite.material.map.image.getContext('2d');
            ctx.clearRect(0,0,512,128);
            if(camera.position.z < 50 && state === "TREE") {
                ctx.fillText("l√†m tr√°i tim ƒëi s·∫Ω c√≥ b·∫•t ng·ªù", 256, 64);
                textSprite.material.opacity = 1;
            } else if(state === "HEART") {
                ctx.fillText("tao ch∆∞a c√≥ qu√† ^ ^", 256, 64);
                textSprite.material.opacity = 1;
                pts.rotation.y += 0.02;
            } else { textSprite.material.opacity = 0; }
            textSprite.material.map.needsUpdate = true;

            renderer.render(scene, camera);
        }

        async function startCamera() {
            const video = document.getElementById('pip-video');
            const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.8});
            hands.onResults(res => {
                if(res.multiHandLandmarks.length === 1) {
                    rotY = (res.multiHandLandmarks[0][8].x - 0.5) * 4;
                } else if(res.multiHandLandmarks.length === 2) {
                    const h1 = res.multiHandLandmarks[0], h2 = res.multiHandLandmarks[1];
                    zoom = Math.max(1, Math.hypot(h1[9].x - h2[9].x, h1[9].y - h2[9].y) * 5);
                    const d1 = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);
                    const d2 = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
                    if(d1 < 0.05 && d2 < 0.05 && state === "TREE") {
                        state = "HEART"; drawHeart();
                        setTimeout(() => { state = "TREE"; drawTree(); }, 6000);
                    }
                }
            });
            const cam = new Camera(video, {onFrame: async () => await hands.send({image: video}), width: 640, height: 480});
            cam.start();
        }

        function capture() {
            const a = document.createElement('a');
            a.href = renderer.domElement.toDataURL();
            a.download = 'selfie.png'; a.click();
        }

        document.querySelectorAll('input').forEach(i => i.onchange = drawTree);
        init();
    </script>
</body>
</html>
