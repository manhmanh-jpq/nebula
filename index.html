<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Xmas Neon Perfected</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; background: #0b0b0b; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { position: absolute; width: 100%; height: 100%; }
        
        /* Giao di·ªán Overlay gi·ªëng ·∫£nh m·∫´u */
        #ui-overlay {
            position: absolute; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; text-shadow: 0 0 10px rgba(0,0,0,1);
        }
        .guide-text { font-size: 24px; font-weight: bold; margin: 10px; }
        
        #update-picker {
            position: absolute; top: 20px; right: 20px; background: rgba(30,30,30,0.9);
            padding: 15px; border-radius: 8px; border: 1px solid #444; color: white; width: 250px;
            pointer-events: auto; z-index: 1000;
        }
        .picker-row { display: flex; justify-content: space-between; align-items: center; margin: 8px 0; }
        input[type="color"] { background: none; border: none; width: 40px; height: 20px; cursor: pointer; }

        #pip-container { 
            position: absolute; bottom: 20px; right: 20px; width: 180px; height: 135px; 
            border: 2px solid #555; border-radius: 10px; overflow: hidden;
        }
        #pip-video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

        #bottom-bar {
            position: absolute; bottom: 30px; width: 100%; display: flex; justify-content: center; gap: 15px;
        }
        .btn-action {
            background: white; color: black; padding: 10px 20px; border-radius: 25px;
            font-weight: bold; border: none; cursor: pointer; display: flex; align-items: center; gap: 8px;
        }
    </style>
</head>
<body>

    <div id="ui-overlay">
        <div class="guide-text">1 Tay: Xoay 360 ƒë·ªô m·ªü r·ªông</div>
        <div class="guide-text" style="font-size: 18px; opacity: 0.8;">·ªû ƒê√ÇY L√Ä QUAY N·ªÄN ƒê√ì</div>
    </div>

    <div id="update-picker">
        <b style="font-size: 14px; color: #aaa;">Update picker</b>
        <div class="picker-row">Sao <input type="color" id="c_star" value="#ffffaa"></div>
        <div class="picker-row">L√° 1 <input type="color" id="c_leaf1" value="#004d00"></div>
        <div class="picker-row">L√° 2 <input type="color" id="c_leaf2" value="#008000"></div>
        <div class="picker-row">D√¢y ƒë√®n <input type="color" id="c_light" value="#ffee00"></div>
        <div class="picker-row">G·ªëc <input type="color" id="c_trunk" value="#2d1a00"></div>
    </div>

    <div id="pip-container"><video id="pip-video" autoplay playsinline></video></div>

    <div id="bottom-bar">
        <button class="btn-action" onclick="capture()">üì∑ ·∫§N V√ÄO ƒê√ÇY ƒê·ªÇ SELFI NH√ì BABE</button>
        <button class="btn-action">üéôÔ∏è ƒê√ÇY L√Ä QU√Ä B·∫¶U ƒê·ªé</button>
    </div>

    <div id="canvas-container"></div>

<script>
    let scene, camera, renderer, treeGroup, lightsGroup;
    let zoomTarget = 1, rotYTarget = 0, currentZoom = 1, currentRotY = 0;
    const SMOOTH_FACTOR = 0.04;

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 5000);
        camera.position.set(0, 100, 800);

        renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        treeGroup = new THREE.Group();
        scene.add(treeGroup);

        createTree();
        animate();
        startCamera();
    }

    function createTree() {
        // Clear old tree
        while(treeGroup.children.length > 0) treeGroup.remove(treeGroup.children[0]);

        const colors = {
            star: document.getElementById('c_star').value,
            leaf1: document.getElementById('c_leaf1').value,
            leaf2: document.getElementById('c_leaf2').value,
            light: document.getElementById('c_light').value,
            trunk: document.getElementById('c_trunk').value
        };

        // 1. G·ªëc c√¢y
        const trunkGeo = new THREE.CylinderGeometry(20, 25, 60, 12);
        const trunkMat = new THREE.MeshBasicMaterial({color: colors.trunk});
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = -230;
        treeGroup.add(trunk);

        // L√°
        for(let i=0; i<5; i++) {
            const r = 200 - i*35;
            const h = 120;
            const coneGeo = new THREE.ConeGeometry(r, h, 8, 1, true); // Open ended
            const coneMat = new THREE.LineBasicMaterial({color: i%2==0 ? colors.leaf1 : colors.leaf2, linewidth: 2});
            const cone = new THREE.LineSegments(new THREE.EdgesGeometry(coneGeo), coneMat);
            cone.position.y = -150 + i*70;
            treeGroup.add(cone);
            
            // Th√™m b·ª•i l·∫•p l√°nh
            const pGeo = new THREE.BufferGeometry();
            const pPos = [];
            for(let j=0; j<500; j++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * r;
                pPos.push(Math.cos(angle)*radius, (Math.random()-0.5)*10, Math.sin(angle)*radius);
            }
            pGeo.setAttribute('position', new THREE.Float32BufferAttribute(pPos, 3));
            const pMat = new THREE.PointsMaterial({color: colors.leaf2, size: 2, transparent: true, opacity: 0.6});
            const pPoints = new THREE.Points(pGeo, pMat);
            pPoints.position.y = -150 + i*70;
            treeGroup.add(pPoints);
        }

        // Ng√¥i sao
        const starGeo = new THREE.SphereGeometry(25, 12, 12);
        const starMat = new THREE.MeshBasicMaterial({color: colors.star});
        const star = new THREE.Mesh(starGeo, starMat);
        star.position.y = 220;
        treeGroup.add(star);

        // D√¢y ƒë√®n qu·∫•n quanh (Xo·∫Øn ·ªëc)
        const curvePoints = [];
        for(let i=0; i<200; i++) {
            const t = i / 200;
            const angle = t * Math.PI * 12;
            const radius = (1 - t) * 200;
            const y = -200 + t * 400;
            curvePoints.push(new THREE.Vector3(Math.cos(angle)*radius, y, Math.sin(angle)*radius));
        }
        const curve = new THREE.CatmullRomCurve3(curvePoints);
        const points = curve.getPoints(200);
        const lightGeo = new THREE.BufferGeometry().setFromPoints(points);
        const lightMat = new THREE.LineBasicMaterial({color: colors.light, transparent: true, opacity: 0.4});
        const lightLine = new THREE.Line(lightGeo, lightMat);
        treeGroup.add(lightLine);

        // C√°c b√≥ng ƒë√®n nh·ªè tr√™n d√¢y
        const bulbGeo = new THREE.BufferGeometry();
        const bulbPos = [];
        points.forEach((p, idx) => {
            if(idx % 5 === 0) bulbPos.push(p.x, p.y, p.z);
        });
        bulbGeo.setAttribute('position', new THREE.Float32BufferAttribute(bulbPos, 3));
        const bulbMat = new THREE.PointsMaterial({
            color: colors.light, size: 8, map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/circle.png'),
            transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
        });
        const bulbs = new THREE.Points(bulbGeo, bulbMat);
        treeGroup.add(bulbs);
        lightsGroup = bulbs;
    }

    function animate() {
        requestAnimationFrame(animate);
        
        currentRotY += (rotYTarget - currentRotY) * SMOOTH_FACTOR;
        currentZoom += (zoomTarget - currentZoom) * SMOOTH_FACTOR;
        
        treeGroup.rotation.y = currentRotY;
        camera.position.z = 800 - (currentZoom - 1) * 1200;

        if(lightsGroup) {
            lightsGroup.material.opacity = 0.5 + Math.sin(Date.now() * 0.005) * 0.5;
        }

        renderer.render(scene, camera);
    }

    async function startCamera() {
        const video = document.getElementById('pip-video');
        const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.8});
        
        hands.onResults(res => {
            if(res.multiHandLandmarks.length === 1) {
                // Xoay 1 tay
                rotYTarget += (res.multiHandLandmarks[0][8].x - 0.5) * 0.15;
            } else if(res.multiHandLandmarks.length === 2) {
                // Zoom 2 tay
                const h1 = res.multiHandLandmarks[0][9];
                const h2 = res.multiHandLandmarks[1][9];
                const dist = Math.hypot(h1.x - h2.x, h1.y - h2.y);
                zoomTarget = 0.5 + dist * 3.0; 
            }
        });
        const cam = new Camera(video, {onFrame: async () => await hands.send({image: video}), width: 640, height: 480});
        cam.start();
    }

    function capture() {
        const link = document.createElement('a');
        link.href = renderer.domElement.toDataURL();
        link.download = 'perfect_xmas.png'; link.click();
    }

    document.querySelectorAll('input[type="color"]').forEach(el => el.addEventListener('input', createTree));

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
</script>
</body>
</html>
