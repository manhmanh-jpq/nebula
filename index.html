<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Xmas Perfected - Full Features</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; background: #050505; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { position: absolute; width: 100%; height: 100%; z-index: 1; }
        
        /* Giao di·ªán h∆∞·ªõng d·∫´n gi·ªØa m√†n h√¨nh */
        #central-guide {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; text-align: center; pointer-events: none; z-index: 10;
        }
        .main-instruction { font-size: 28px; font-weight: 800; margin-bottom: 10px; text-shadow: 0 0 15px rgba(255,255,255,0.5); }
        .sub-instruction { font-size: 18px; color: #ccc; text-transform: uppercase; letter-spacing: 2px; }

        /* B·∫£ng m√†u g√≥c ph·∫£i */
        #update-picker {
            position: absolute; top: 20px; right: 20px; background: rgba(20,20,20,0.9);
            padding: 15px; border-radius: 12px; border: 1px solid #333; color: white; width: 220px; z-index: 100;
        }
        .picker-row { display: flex; justify-content: space-between; align-items: center; margin: 8px 0; font-size: 13px; }
        input[type="color"] { background: none; border: none; width: 50px; height: 24px; cursor: pointer; }

        /* Camera nh·ªè g√≥c d∆∞·ªõi */
        #pip-container { 
            position: absolute; bottom: 20px; right: 20px; width: 240px; height: 180px; 
            border: 2px solid #fff; border-radius: 15px; overflow: hidden; z-index: 100; box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #pip-video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

        /* Thanh n√∫t b·∫•m d∆∞·ªõi c√πng */
        #bottom-bar {
            position: absolute; bottom: 30px; width: 100%; display: flex; justify-content: center; gap: 20px; z-index: 100;
        }
        .btn-action {
            background: white; color: black; padding: 12px 25px; border-radius: 30px;
            font-weight: 900; border: none; cursor: pointer; transition: 0.3s; font-size: 14px;
        }
        .btn-action:hover { transform: scale(1.05); background: #f0f0f0; }
    </style>
</head>
<body>

    <div id="central-guide">
        <div class="main-instruction" id="guide-main">1 Tay: Xoay 360¬∞ m·ªü r·ªông</div>
        <div class="sub-instruction" id="guide-sub">·ªî ƒê√ÇY L√Ä QUAY N·ªÄN ƒê√ì</div>
    </div>

    <div id="update-picker">
        <div style="font-weight: bold; border-bottom: 1px solid #444; padding-bottom: 5px; margin-bottom: 10px;">Update picker</div>
        <div class="picker-row">Sao <input type="color" id="c0" value="#ffffaa"></div>
        <div class="picker-row">L√° 1 <input type="color" id="c1" value="#004d00"></div>
        <div class="picker-row">L√° 2 <input type="color" id="c2" value="#008000"></div>
        <div class="picker-row">L√° 3 <input type="color" id="c3" value="#228b22"></div>
        <div class="picker-row">D√¢y ƒë√®n <input type="color" id="c4" value="#ffcc00"></div>
        <div class="picker-row">G·ªëc <input type="color" id="c5" value="#2d1a00"></div>
    </div>

    <div id="pip-container"><video id="pip-video" autoplay playsinline></video></div>

    <div id="bottom-bar">
        <button class="btn-action" onclick="capture()">üì∑ ·∫§N V√ÄO ƒê√ÇY ƒê·ªÇ SELFI NH√ì BABE</button>
        <button class="btn-action">üéôÔ∏è ƒê√ÇY L√Ä QU√Ä B·∫¶U ƒê·ªé</button>
    </div>

    <div id="canvas-container"></div>

<script>
    let scene, camera, renderer, treeGroup, textSprite, pts;
    let zoomTarget = 1, rotYTarget = 0, currentZoom = 1, currentRotY = 0;
    let state = "TREE"; // TREE, SPHERE, HEART
    const SMOOTH_FACTOR = 0.04;

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 5000);
        camera.position.z = 800;

        renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        treeGroup = new THREE.Group();
        scene.add(treeGroup);

        // Kh·ªüi t·∫°o Text Sprite (Ch·ªØ trong l√µi)
        const canvas = document.createElement('canvas');
        canvas.width = 1024; canvas.height = 256;
        const tex = new THREE.CanvasTexture(canvas);
        textSprite = new THREE.Sprite(new THREE.SpriteMaterial({map: tex, transparent: true, depthTest: false}));
        textSprite.scale.set(600, 150, 1);
        textSprite.position.y = 50;
        scene.add(textSprite);

        // Kh·ªüi t·∫°o h·∫°t b·ª•i (cho Sphere v√† Heart)
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(15000 * 3);
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        const mat = new THREE.PointsMaterial({
            size: 4, color: 0xffffff, transparent: true, blending: THREE.AdditiveBlending,
            map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/circle.png'),
            depthWrite: false
        });
        pts = new THREE.Points(geo, mat);
        pts.visible = false;
        scene.add(pts);

        updateObject();
        animate();
        startCamera();
    }

    function updateObject() {
        // X√≥a c√¢y c≈© n·∫øu ƒëang ·ªü mode TREE
        while(treeGroup.children.length > 0) treeGroup.remove(treeGroup.children[0]);
        pts.visible = false;

        const c = [0,1,2,3,4,5].map(i => document.getElementById('c'+i).value);

        if (state === "TREE") {
            // V·∫Ω c√¢y th√¥ng Neon
            for(let i=0; i<4; i++) {
                const r = 200 - i*45;
                const coneGeo = new THREE.ConeGeometry(r, 120, 8, 1, true);
                const coneMat = new THREE.LineBasicMaterial({color: c[i+1], linewidth: 2});
                const cone = new THREE.LineSegments(new THREE.EdgesGeometry(coneGeo), coneMat);
                cone.position.y = -150 + i*80;
                treeGroup.add(cone);
            }
            // D√¢y ƒë√®n v√†ng qu·∫•n quanh
            const curvePts = [];
            for(let i=0; i<100; i++) {
                const t = i/100; const a = t*Math.PI*10; const r = (1-t)*200;
                curvePts.push(new THREE.Vector3(Math.cos(a)*r, -200 + t*400, Math.sin(a)*r));
            }
            const lightGeo = new THREE.BufferGeometry().setFromPoints(curvePts);
            const lightMat = new THREE.PointsMaterial({color: c[4], size: 6, transparent: true, blending: THREE.AdditiveBlending});
            treeGroup.add(new THREE.Points(lightGeo, lightMat));

            // Ng√¥i sao
            const star = new THREE.Mesh(new THREE.SphereGeometry(20,8,8), new THREE.MeshBasicMaterial({color: c[0]}));
            star.position.y = 210;
            treeGroup.add(star);

        } else {
            // Ch·∫ø ƒë·ªô SPHERE ho·∫∑c HEART d√πng h·∫°t b·ª•i
            pts.visible = true;
            const pos = pts.geometry.attributes.position.array;
            for(let i=0; i<15000; i++) {
                let x,y,z;
                if(state === "SPHERE") {
                    const phi = Math.acos(-1 + (2*i)/15000);
                    const theta = Math.sqrt(15000*Math.PI)*phi;
                    x = 300*Math.cos(theta)*Math.sin(phi);
                    y = 300*Math.sin(theta)*Math.sin(phi);
                    z = 300*Math.cos(phi);
                    pts.material.color.set(0x00ffcc);
                } else {
                    const t = Math.random()*Math.PI*2;
                    const p = Math.random()*Math.PI;
                    x = 18 * 16 * Math.pow(Math.sin(t), 3) * Math.sin(p);
                    y = 18 * (13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t)) * Math.sin(p);
                    z = 18 * 10 * Math.cos(p) * Math.sin(p);
                    pts.material.color.set(0xff3333);
                }
                pos[i*3]=x; pos[i*3+1]=y; pos[i*3+2]=z;
            }
            pts.geometry.attributes.position.needsUpdate = true;
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        currentRotY += (rotYTarget - currentRotY) * SMOOTH_FACTOR;
        currentZoom += (zoomTarget - currentZoom) * SMOOTH_FACTOR;
        
        treeGroup.rotation.y = currentRotY;
        pts.rotation.y = currentRotY;
        camera.position.z = 800 - (currentZoom - 1) * 1600;

        // Logic chuy·ªÉn c·∫£nh v√† hi·ªán ch·ªØ
        const ctx = textSprite.material.map.image.getContext('2d');
        ctx.clearRect(0,0,1024,256);
        ctx.textAlign = "center"; ctx.fillStyle = "white"; ctx.font = "bold 60px Arial";

        if (camera.position.z < 150 && state === "TREE") {
            state = "SPHERE"; updateObject();
        } else if (camera.position.z > 200 && state === "SPHERE") {
            state = "TREE"; updateObject();
        }

        if(state === "SPHERE") {
            ctx.fillText("L√ÄM TR√ÅI TIM ƒêI S·∫º C√ì B·∫§T NG·ªú", 512, 128);
            textSprite.material.opacity = 1;
        } else if(state === "HEART") {
            ctx.fillText("T·∫∂NG BABE C√ÇY TH√îNG N√à ^ ^", 512, 128);
            textSprite.material.opacity = 1;
            rotYTarget += 0.02; // T·ª± xoay
        } else {
            textSprite.material.opacity = 0;
        }
        textSprite.material.map.needsUpdate = true;
        renderer.render(scene, camera);
    }

    async function startCamera() {
        const video = document.getElementById('pip-video');
        const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.8});
        
        hands.onResults(res => {
            if(res.multiHandLandmarks.length === 1) {
                rotYTarget += (res.multiHandLandmarks[0][8].x - 0.5) * 0.2;
                document.getElementById('guide-main').innerText = "1 Tay: Xoay 360¬∞ m·ªü r·ªông";
            } else if(res.multiHandLandmarks.length === 2) {
                const h1 = res.multiHandLandmarks[0], h2 = res.multiHandLandmarks[1];
                const dist = Math.hypot(h1[9].x - h2[9].x, h1[9].y - h2[9].y);
                zoomTarget = 1 + dist * 4.5;
                document.getElementById('guide-main').innerText = "2 Tay: Ph√≥ng to thu nh·ªè";

                // CH·ª§M TAY RA TR√ÅI TIM (Ng√≥n c√°i v√† ng√≥n tr·ªè c·ªßa 2 tay ch·∫°m nhau)
                const dStar = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);
                if(dStar < 0.06 && state !== "HEART") {
                    state = "HEART"; updateObject();
                    setTimeout(() => { state = "TREE"; updateObject(); }, 7000);
                }
            }
        });
        const cam = new Camera(video, {onFrame: async () => await hands.send({image: video}), width: 640, height: 480});
        cam.start();
    }

    function capture() {
        const link = document.createElement('a');
        link.href = renderer.domElement.toDataURL();
        link.download = 'selfie_xmas.png'; link.click();
    }

    document.querySelectorAll('input').forEach(i => i.onchange = updateObject);
    init();
</script>
</body>
</html>
